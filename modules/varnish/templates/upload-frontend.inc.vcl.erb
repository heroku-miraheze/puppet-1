include "normalize_path.inc.vcl";

/******************************************************************************
 * upload.wikimedia.org:
 * MW seems to use PHP's rawurlencode() directly when translating from
 * MediaWiki File titles to storage URLs, without additional exceptions.
 * Therefore, all 16 characters from the Customizable Set are all changed to
 * zero-values here (force-encode) to obtain complete normalization:
 *****************************************************************************/

sub normalize_upload_path { C{
    static const size_t upload_decoder_ring[256] = {
      // 0x00-0x1F (all unprintable)
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
      //  ! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ?
        0,0,0,2,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,2,
      //@ A B C D E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _
        0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,1,
      //` a b c d e f g h i j k l m n o p q r s t u v w x y z { | } ~ <DEL>
        0,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,1,0,
      // 0x80-0xFF (all unprintable)
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
        0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
    };

    normalize_path_encoding(ctx, upload_decoder_ring);
}C }

// For: Temporary experiment in reducing facebookexternalhit / facebookexternalua traffic to cache_upload
acl fb_nets {
	"31.13.24.0"/21;
	"31.13.64.0"/18;
	"45.64.40.0"/22;
	"66.220.144.0"/20;
	"69.63.176.0"/20;
	"69.171.224.0"/19;
	"74.119.76.0"/22;
	"103.4.96.0"/22;
	"157.240.0.0"/17;
	"173.252.64.0"/19;
	"173.252.96.0"/19;
	"179.60.192.0"/22;
	"185.60.216.0"/22;
	"204.15.20.0"/22;
	"2620:0:1c00::0"/40;
	"2620:0:1cff::0"/48;
	"2a03:2880::0"/32;
}

sub cluster_fe_vcl_switch { }

sub cluster_fe_recv_pre_purge {
	// Normalize paths before purging
	if (req.http.host ~ "^upload\.wikimedia\.org$") {
		call normalize_upload_path;
	}
}

sub cluster_fe_recv {
	// The upload cluster does not serve page views or authenticated
	// requests, so we keep it cookie-free on the sending side in
	// vcl_deliver to avoid pointless network traffic and to improve
	// cacheability.  Here we'll also strip Auth/Cookie info at ingress
	// as well, as this information should be at best pointless and could
	// cause functional issues.
	unset req.http.Authorization;
	unset req.http.Cookie;
        set resp.http.Alt-Svc = 'h3-25=":443"; ma=3600, h2=":443"; ma=3600, quic=":443"; ma=3600; v="12,22,32"';
	// 421 for bad H/2 coalesce (wikimedia-frontend handles synth)
	if (req.http.Host != "<%= @vcl_config.fetch('upload_domain') %>"
	    && req.http.Host != "<%= @vcl_config.fetch('maps_domain') %>") {
		return (synth(421, "Misdirected Request"));
	}

	if (req.http.host == "<%= @vcl_config.fetch('upload_domain') %>") {
		// CORS preflight requests
		if (req.method == "OPTIONS" && req.http.Origin) {
			return (synth(200, "CORS Preflight"));
		}

		// Homepage redirect to commons
		if (req.url == "/") {
			return (synth(301, "Commons Redirect"));
		}
	}

	unset req.http.X-Range;

	if (req.http.host != "<%= @vcl_config.fetch('upload_domain') %>"
	    && req.http.host != "<%= @vcl_config.fetch('maps_domain') %>") {
		return (synth(404, "Requested domainname does not exist on this server"));
	}

	if (req.http.Range) {
		set req.hash_ignore_busy = true;
	}

	if (req.http.host == "<%= @vcl_config.fetch('upload_domain') %>") {
		// Look for a "download" request parameter
		if (req.url ~ "(?i)(\?|&)download(=|&|$)") {
			set req.http.X-Content-Disposition = "attachment";
		}

		// Strip away all query parameters
		set req.url = regsub(req.url, "\?.*$", "");

		// Replace double slashes
		set req.url = regsuball(req.url, "/{2,}", "/");

		// Thumb fixups
		if (req.url ~ "(?i)/thumb/") {
			if (req.url !~ "(?i)\.(jpg|jpeg|jpe|gif|png|webp)$") {
				// Invalid file extension
				return (synth(400, "Bad Request"));
			}

			// Normalize end of thumbnail URL (redundant filename)
			// Lowercase last part of the URL, to avoid case variations on extension or thumbnail parameters
			// eg. /wikipedia/commons/thumb/0/06/Foo.jpg/120px-FOO.JPG => /wikipedia/commons/thumb/0/06/Foo.jpg/120px-foo.jpg
			set req.url = regsub(req.url, "^(.+/)[^/]+$", "\1") + std.tolower(regsub(req.url, "^.+/([^/]+)$", "\1"));

			// In the abbreviated case, where MediaWiki turns the end of the thumbnail URL into -thumbnail.ext
			// (see abbrvThreshold in FileRepo), there is no need to copy over the canonical filename
			// However, we filter out potentially abusive use of -thumbnail.ext on short filenames (<= 160 characters), where the
			// normalization is warranted.
			if ( req.url ~ "[^/]{161,}/[^/]+$" ) {
				// Abbreviated case, ensure that the end of the URL is thumbnail.ext
				set req.url = regsub(req.url, "/([^/]+)/((?:qlow-)?(?:lossy-)?(?:lossless-)?(?:page\d+-)?(?:lang[0-9a-z-]+-)?\d+px-(?:(?:seek=|seek%3d)\d+-)?)[^/]+\.(\w+)$", "/\1/\2thumbnail.\3");
			} else {
				// Copy canonical filename from beginning of URL to thumbnail parameters at the end
				// eg. /wikipedia/commons/thumb/0/06/Foo.jpg/120px-bar.jpg => /wikipedia/commons/thumb/0/06/Foo.jpg/120px-Foo.jpg.jpg
				set req.url = regsub(req.url, "/([^/]+)/((?:qlow-)?(?:lossy-)?(?:lossless-)?(?:page\d+-)?(?:lang[0-9a-z-]+-)?\d+px-(?:(?:seek=|seek%3d)\d+-)?)[^/]+\.(\w+)$", "/\1/\2\1.\3");

				// Last pass, clean up any redundant extension
				// .jpg.jpg => .jpg, .JPG.jpg => .JPG
				// eg. /wikipedia/commons/thumb/0/06/Foo.jpg/120px-Foo.jpg.jpg => /wikipedia/commons/thumb/0/06/Foo.jpg/120px-Foo.jpg
				if (req.url ~ "(?i)(.*)(\.\w+)\2$") {
					set req.url = regsub(req.url, "(?i)(.*)(\.\w+)\2$", "\1\2");
				}
			}
		}
	}

	// Fixup borked client Range: headers
	if (req.http.Range ~ "(?i)bytes:") {
		set req.http.Range = regsub(req.http.Range, "(?i)bytes:\s*", "bytes=");
	}
}

sub cluster_fe_recv_tail { }
sub cluster_fe_hash { }
sub cluster_fe_hit { }

sub cluster_fe_ratelimit {
	// dont apply any rate limiting to internal networks
	// Fallback to 192.0.2.1, from rfc5735's TEST-NET-1, which is not in wikimedia_nets
	if (std.ip(req.http.X-Client-IP, "192.0.2.1") !~ wikimedia_nets) {
		// ratelimit FB in an attempt to mitigate awful outbound traffic spike
		if (std.ip(req.http.X-Client-IP, "192.0.2.1") ~ fb_nets) {
			if (vsthrottle.is_denied("fb_limiter", 1000, 30s)) {
				return (synth(429, "Too Many Requests"));
			}
		}

		// Requests in violation of the User-Agent policy
		if (req.http.User-Agent ~ "^python-requests") {
			// UA-policy violations: 10/10s (1/s long term, with 10 burst)
			if (vsthrottle.is_denied("ua-policy:" + req.http.X-Client-IP, 10, 10s)) {
				return (synth(429, "Too many requests. Please comply with the User-Agent policy to get a higher rate limit: https://meta.wikimedia.org/wiki/User-Agent_policy"));
			}
		}

		// geoshape limit rate: 10/10s (1/s long term, with 10 burst)
		if (req.http.Host == "<%= @vcl_config.fetch('maps_domain') %>" && req.url ~ "/geoshape") {
			if (vsthrottle.is_denied("maps-geoshape:" + req.http.X-Client-IP, 10, 10s)) {
				return (synth(429, "Too Many Requests"));
			}
		}

		// Maps rate limiting: 1000/10s (100/s long term, with 1000 burst)
		if (req.http.Host == "<%= @vcl_config.fetch('maps_domain') %>") {
			if (vsthrottle.is_denied("maps:" + req.http.X-Client-IP, 1000, 10s)) {
				return (synth(429, "Too Many Requests"));
			}
			// below is attempted mitigation of https://phabricator.wikimedia.org/T244278
			if (req.http.referer && req.http.referer !~ "^https?://(([^/]*\.)*(wikipedia|wikimedia|wikibooks|wikinews|wikiquote|wikisource|wikiversity|wikivoyage|wikidata|wikimediafoundation|wiktionary|mediawiki|wmfusercontent|wmflabs|toolforge|wmcloud)\.org|w\.wiki|localhost(:\d*)?)(/|$)") {
				return (synth(429, "Too Many Requests"));
			}
		}

		// Thumbor rate limiting: 1000/10s (100/s long term, with 1000 burst)
		if (req.url ~ "/thumb/") {
			// No idea what the correct values should be here?
			if (vsthrottle.is_denied("thumbor:" + req.http.X-Client-IP, 1000, 10s)) {
				return (synth(429, "Too Many Requests"));
			}
		}

		// General upload rate limiting: 5000/10s (500/s long term, with 5000 burst)
		if (vsthrottle.is_denied("general:" + req.http.X-Client-IP, 5000, 10s)) {
			return (synth(429, "Too Many Requests"));
		}
	}
}

sub cluster_fe_miss {
	call cluster_fe_ratelimit;

	// Convert range requests into pass
	if (req.http.Range) {
		// Varnish strips the Range header before copying req into bereq. Save it into
		// a header and restore it in cluster_fe_backend_fetch
		set req.http.X-Range = req.http.Range;
		return (pass);
	}
}

sub cluster_fe_pass {
	call cluster_fe_ratelimit;
}

sub cluster_fe_backend_fetch {
	if (bereq.http.X-Range) {
		set bereq.http.Range = bereq.http.X-Range;
		unset bereq.http.X-Range;
	}
}

sub cluster_fe_backend_response_early { }

sub cluster_fe_backend_response {
	if (beresp.http.Content-Range) {
		// Varnish itself doesn't ask for ranges, so this must have been
		// a passed range request
		set beresp.http.X-Content-Range = beresp.http.Content-Range;
	}

	// Debugging T144257. Don't cache 200 responses with CL:0.
	if (beresp.http.Content-Length == "0" && beresp.status == 200) {
		// HFM
		set beresp.ttl = 10m;
		set beresp.grace = 0s;
		set beresp.keep = 0s;
		set beresp.uncacheable = true;
	}
}

sub cluster_fe_deliver {
	if (resp.http.X-Content-Range) {
		set resp.http.Content-Range = resp.http.X-Content-Range;
		unset resp.http.X-Content-Range;
	}

	// The upload cluster does not serve page views or authenticated requests, so keep
	// it cookie-free to avoid pointless network traffic and to improve cacheability.
	unset resp.http.Set-Cookie;
	unset resp.http.X-MediaWiki-Original;

	if (req.http.host == "<%= @vcl_config.fetch('upload_domain') %>") {
		// In general, do not send Cache-Control. Exceptions such as setting CC for
		// specific clients can be specified further down in this subroutine.
		unset resp.http.Cache-Control;
	}

	// Strip away unnecessary response headers set by Thumbor: T194814
	unset resp.http.Thumbor-Request-Id;
	unset resp.http.Thumbor-Request-Date;
	unset resp.http.Thumbor-Processing-Utime;
	unset resp.http.Thumbor-Engine;
	unset resp.http.Thumbor-Processing-Time;

	if (req.http.X-Content-Disposition == "attachment") {
		set resp.http.Content-Disposition = "attachment";
	}

	// Workaround for broken Content-Type due to Swift bug T162035/T188831
	if (resp.http.Content-Type == "application/x-www-form-urlencoded") {
		if (req.url ~ "(?i)\.(jpg|jpeg|jpe)$") {
			set resp.http.Content-Type = "image/jpeg";
		} else if (req.url ~ "(?i)\.png$") {
			set resp.http.Content-Type = "image/png";
		} else if (req.url ~ "(?i)\.webp$") {
			set resp.http.Content-Type = "image/webp";
		}
	}

	if (req.http.host == "<%= @vcl_config.fetch('upload_domain') %>") {
		set resp.http.Access-Control-Allow-Origin = "*";

		// Headers exposed for CORS:
		// - Age, Content-Length, Date, X-Cache
		//
		// - X-Content-Duration: used for OGG audio and video files (7077999966).
		//   Firefox 41 dropped support for this header, but OGV.js still supports it.
		//   See <https://bugzilla.mozilla.org/show_bug.cgi?id=1160695#c27> and
		//   <https://github.com/brion/ogv.js/issues/88>.
		//
		// - Content-Range: indicates total file and actual range returned for RANGE
		//   requests (939b436512). Used by ogv.js to eliminate an extra HEAD request
		//   to get the the total file size.
		set resp.http.Access-Control-Expose-Headers = "Age, Date, Content-Length, Content-Range, X-Content-Duration, X-Cache";

		// "Timing-Allow-Origin" is part of the Resource Timing specification
		// (https://www.w3.org/TR/resource-timing/). Setting this header allows
		// JavaScript with a different origin to access resource timing info
		// (e9cbfd539edd3). See <https://phabricator.wikimedia.org/T76020>.
		set resp.http.Timing-Allow-Origin = "*";

		// Restrict uploads from loading external resources. (T117618)
		// Currently experimental and testing on large but not huge wikis.
		if (req.url ~ "^/wikipedia/(el|fr|ru|it|de|uk|ja|id|he|fi|zh|test)") {
			set resp.http.Content-Security-Policy-Report-Only = "default-src 'none'; style-src 'unsafe-inline' data:; font-src data:; img-src data: https://upload.wikimedia.org/favicon.ico; media-src data:; sandbox; report-uri https://commons.wikimedia.org/w/api.php?reportonly=1&source=image&action=cspreport&format=json&";
			set resp.http.X-Content-Security-Policy-Report-Only = resp.http.Content-Security-Policy-Report-Only;
			set resp.http.X-Webkit-CSP-Report-Only = resp.http.Content-Security-Policy-Report-Only;
		}
	}


	// Temporary experiment in reducing facebookexternalhit / facebookexternalua traffic to cache_upload
	if (std.ip(req.http.X-Client-IP, "192.0.2.1") ~ fb_nets
		&& (resp.status == 200 || resp.status == 206)) {
			set resp.http.Cache-control = "public, max-age=3600, s-maxage=3600";
			set resp.http.Age = "0";
	}

	# If the client supports WebP and the thumbnail is popular enough, attempt to serve a WebP thumbnail instead of JPG/PNG
	if (obj.hits > <%= @vcl_config.fetch('upload_webp_hits_threshold') %> && req.url ~ "(?i)\.(jpg|jpeg|jpe|png)$" && req.url ~ "(?i)/thumb/" && req.http.Accept ~ "(?i)image/webp" && req.http.User-Agent !~ "^Opera" && req.restarts == 0) {
		# Append .webp to the request URL
		set req.url = req.url + ".webp";
		return(restart);
	}

	# The WebP thumbnail failed, fall back to the JPG/PNG one
	if (resp.status >= 400 && req.restarts >= 1 && req.url ~ "(?i)\.webp$" && req.url ~ "(?i)/thumb/") {
		# Remove .webp from the request URL
		set req.url = regsub(req.url, "(?i)\.webp$", "");
		return(restart);
	}
}

sub cluster_fe_err_synth {
	if (req.http.host == "<%= @vcl_config.fetch('upload_domain') %>") {
		// Handle CORS preflight requests
		if (resp.reason == "CORS Preflight") {
			set resp.reason = "OK";
			set resp.http.Connection = "keep-alive";
			set resp.http.Content-Length = "0";

			// allow Range requests, used by ogv.js
			// also avoid strange errors when testing on a debug host
			set resp.http.Access-Control-Allow-Origin = "*";
			set resp.http.Access-Control-Allow-Headers = "Range,X-Wikimedia-Debug";
			set resp.http.Access-Control-Allow-Methods = "GET, HEAD, OPTIONS";
			set resp.http.Access-Control-Max-Age = "86400";
		}

		// Homepage redirect to commons
		if (resp.reason == "Commons Redirect") {
			set resp.reason = "Moved Permanently";
			set resp.http.Location = "https://commons.wikimedia.org/";
			set resp.http.Connection = "keep-alive";
			set resp.http.Content-Length = "0";
		}
	}
}
# vim: set autoindent noexpandtab tabstop=4 shiftwidth=4:
